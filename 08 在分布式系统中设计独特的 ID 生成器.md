在本章中，你需要在分布式系统中设计一个独特的 ID 生成器。你的第一个想法可能是在传统数据库中使用带有*auto_increment属性的主键。*然而，*auto_increment*不适用于分布式环境，因为单个数据库服务器不够大，并且以最小的延迟跨多个数据库生成唯一 ID 具有挑战性。

以下是唯一 ID 的一些示例：

![](./images/8/1.svg)

图1

## 第 1 步 - 了解问题并确定设计范围

提出澄清问题是解决任何系统设计面试问题的第一步。以下是候选人与面试官互动的示例：

**候选人**：唯一ID有什么特点？
**面试官**：ID必须是唯一的并且可排序。

**候选人**：每一条新记录，ID 都会加 1 吗？
**面试官**：ID是按时间递增的，但不一定只递增1。当天晚上创建的ID比早上创建的ID要大。

**候选人**：ID 只包含数字值吗？
**面试官**：是的，这是正确的。

**候选人**：身份证件长度要求是多少？
**面试官**：ID应该适合64位。

**候选人**：系统的规模有多大？
**面试官**：系统应该能够每秒生成10000个ID。

以上是你可以向面试官提出的一些示例问题。了解要求并澄清歧义非常重要。对于本次面试问题，要求如下：

- ID 必须是唯一的。
- ID 仅是数值。
- ID 适合 64 位。
- ID 按日期排序。
- 每秒能够生成超过 10,000 个唯一 ID。

## 第 2 步 - 提出高级设计并获得认可

可以使用多个选项在分布式系统中生成唯一 ID。我们考虑的选项是：

- 多主复制
- 通用唯一标识符 (UUID)
- 票务服务器
- Twitter雪花方法

让我们看看它们中的每一个、它们的工作原理以及每个选项的优缺点。

### 多主复制

如图2所示，第一种方法是多主复制。

![](./images/8/2.svg)

图2

这种方法使用数据库的*自动增量*功能。我们不是将下一个 ID 加 1，而是将其加*k，*其中*k*是正在使用的数据库服务器的数量。如图 2 所示，要生成的下一个 ID 等于同一服务器中的前一个 ID 加 2。这解决了一些可扩展性问题，因为 ID 可以随着数据库服务器的数量而扩展。然而，这种策略有一些主要缺点：

- 难以通过多个数据中心进行扩展
- ID 不会随着时间跨多个服务器而增加。
- 添加或删除服务器时，它不能很好地扩展。

### 通用唯一标识符

UUID 是获取唯一 ID 的另一种简单方法。UUID 是一个 128 位数字，用于识别计算机系统中的信息。UUID 串通的可能性非常低。引用维基百科的说法，“在大约 100 年内每秒生成 10 亿个 UUID 后，创建单个重复项的概率将达到 50%”[1]。

以下是 UUID 的示例：09c93e62-50b4-468d-bf8a-c07e1040bfb2。UUID 可以独立生成，无需服务器之间协调。图 3 展示了 UUID 设计。

![](./images/8/3.svg)

图3

在本设计中，每个Web服务器都包含一个ID生成器，并且Web服务器负责独立生成ID。

优点：

- 生成 UUID 很简单。服务器之间不需要协调，因此不会出现任何同步问题。
- 该系统很容易扩展，因为每个 Web 服务器负责生成它们使用的 ID。ID 生成器可以轻松地与 Web 服务器一起扩展。

缺点：

- ID 的长度是 128 位，但我们的要求是 64 位。
- ID 不会随着时间而增加。
- ID 可以是非数字的。

### 票务服务器

票证服务器是生成唯一 ID 的另一种有趣方式。Flicker 开发了票证服务器来生成分布式主键 [2]。值得一提的是该系统的工作原理。

![](./images/8/4.svg)

图4

这个想法是在单个数据库服务器（票务服务器）中使用集中式*自动增量功能。*要了解更多相关信息，请参阅 flicker 的工程博客文章 [2]。

优点：

- 数字 ID。
- 它易于实现，适用于中小型应用程序。

缺点：

- 单点故障。单一票证服务器意味着如果票证服务器出现故障，所有依赖它的系统都将面临问题。为了避免单点故障，我们可以设置多个票证服务器。然而，这会带来新的挑战，例如数据同步。

### Twitter 雪花方法

上述方法为我们提供了一些关于不同 ID 生成系统如何工作的想法。然而，它们都不符合我们的具体要求；因此，我们需要另一种方法。Twitter 独特的 ID 生成系统“雪花”[3] 很鼓舞人心，可以满足我们的要求。

分而治之是我们的朋友。我们不是直接生成ID，而是将ID分成不同的部分。图 5 显示了 64 位 ID 的布局。

![](./images/8/5.svg)

图5

每个部分的解释如下。

- 符号位：1位。它始终为 0。这是为将来使用而保留的。它可以用来区分有符号数和无符号数。
- 时间戳：41 位。自纪元或自定义纪元以来的毫秒数。我们使用 Twitter 雪花默认纪元 1288834974657，相当于 2010 年 11 月 4 日，01:42:54 UTC。
- 数据中心 ID：5 位，这给了我们*2 ^ 5 = 32 个*数据中心。
- 机器 ID：5 位，每个数据中心有*2 ^ 5 = 32*台机器。
- 序列号：12位。对于该机器/进程上生成的每个 ID，序列号都会增加 1。该数字每毫秒重置为 0。

## 第 3 步 - 设计深入研究

在高层设计中，我们讨论了在分布式系统中设计独特 ID 生成器的各种选项。我们选择了一种基于 Twitter 雪花 ID 生成器的方法。让我们深入了解设计。为了加深我们的记忆，下面重新列出了设计图。

![](./images/8/6.svg)

图6

数据中心 ID 和机器 ID 在启动时选择，通常在系统启动运行后固定。数据中心 ID 和计算机 ID 的任何更改都需要仔细检查，因为这些值的意外更改可能会导致 ID 冲突。时间戳和序列号是在 ID 生成器运行时生成的。

**时间戳**

最重要的 41 位组成了时间戳部分。由于时间戳随时间增长，ID 可以按时间排序。图 7 显示了如何将二进制表示形式转换为 UTC 的示例。你还可以使用类似的方法将 UTC 转换回二进制表示形式。

![](./images/8/7.svg)

图7

可以用 41 位表示的最大时间戳为

$2^{41} - 1 = 2199023255551$毫秒 (ms)，这给我们： ~ 69 年 = *2199023255551 ms / 1000 / 365 天 / 24 小时/ 3600 秒*。这意味着 ID 生成器将工作 69 年，并且具有接近今天日期的自定义纪元时间会延迟溢出时间。69年后，我们将需要一个新的纪元时间或采用其他技术来迁移ID。

序列号

序列号是 12 位，这给了我们 $2^{12} = 4096$ 种组合。除非同一服务器上一毫秒内生成多个 ID，否则该字段为 0。理论上，一台机器每毫秒最多可以支持4096个新ID。

## 第 4 步 - 总结

在本章中，我们讨论了设计唯一 ID 生成器的不同方法：多主复制、UUID、票证服务器和 Twitter 雪花式唯一 ID 生成器。我们选择了雪花，因为它支持我们所有的用例并且可以在分布式环境中扩展。

如果采访结束时还有额外的时间，这里有一些额外的谈话要点：

- 时钟同步。在我们的设计中，我们假设 ID 生成服务器具有相同的时钟。当服务器在多个内核上运行时，这种假设可能不成立。多机场景也存在同样的挑战。时钟同步的解决方案超出了本课程的范围；然而，重要的是要了解问题的存在。网络时间协议是该问题最流行的解决方案。有兴趣的读者可以参考参考资料[4]。
- 节长度调整。例如，较少的序列号但较多的时间戳位对于低并发和长期的应用程序是有效的。
- 高可用性。由于 ID 生成器是一个关键任务系统，因此它必须具有高可用性。

恭喜你已经走到这一步了！现在拍拍自己的背吧。好工作！

## 参考资料

[1] 通用唯一标识符：
[https ://en.wikipedia.org/wiki/Universally_unique_identifier](https://en.wikipedia.org/wiki/Universally_unique_identifier)

[2] 票证服务器：廉价的分布式唯一主键：
[https ://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/](https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/)

[3] 宣布雪花：
https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake.html

[4] 网络时间协议：
https://en.wikipedia.org/wiki/Network_Time_Protocol